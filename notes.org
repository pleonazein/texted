#+TITLE: Notes on Building a Texteditor

* Notes

** Commit 1

+ created =main=.
+ compiled using a Makefile. Makefiles help automate the process of compilation; simply running =./make= in the folder containing the Makefile will compile according to specifications.
#+BEGIN_SRC 
kilo.c: kilo
    $(CC) kilo.c -o kilo -Wall -Wextra -pedantic -std=c99
#+END_SRC
+ the final executable is in a file named /kilo/; running =./kilo= yields nothing, however the final return value can be checked in the shell by running =echo $?=.

*** TODO Ponderables [0/2]:

+ [ ] how are Makefiles structured? (what is meant by =kilo.c: kilo= etc.)
+ [ ] what is =?= in the shell?
+ [ ] how are commit messages displayed in git, and on the Github site?

** Commit 2

+ this commit is going to continuously read characters from the terminal's input.
+ the prototype of =read= is:
#+BEGIN_SRC C
ssize_t read (int file_descriptor, void *buffer, size_t nbytes);
#+END_SRC

  + read =nbytes= bytes from =file_descriptor= into the buffer.
  + in general =read=, can read from files, with offsets etc. see =man 3 read= for more details.
  + the value returned is the number of bytes read -- is less that =nbytes=, in case the file/pipe has fewer bytes than is requested.
  + in our case, a successful read will have read a single byte, thus returning 1.

  + The current mode in the terminal is *canonical/cooked* mode. Keyboard input is sent to the terminal only upon hitting RET or =C-d= (EOF).
  + This allows for editing with Backspace etc.
  + =C-d= and =C-c= help terminate the program. =C-d= sends the program =EOF=, indicating that there are no more bytes to be read. =C-c= terminates the process immediately.
  + =unistd.h= provides =read= and =STDIN_FILENO=

*** DONE Ponderables [2/2]:

+ [X] what exactly is happening when several letters are sent to the program after pressing Return? (in Canonical mode, that is)?
*ANSWER*: I tested it out by making the loop echo back the input characters. the output is as follows:

+ [X] =STDIN_FILENO=. What is it?
*ANSWER*: I made the test program print out its value -- it was 0. =unistd.h= defines it to be 0, along with =STDOUT_FILENO=(1) and =STDERR_FILENO=(2).

#+BEGIN_SRC 
> ./testkilo
abcd RET
a
b
c
d

_
#+END_SRC

** Commit 3

+ this commit has the loop modified to quit upon pressing =q=. simple enough.
+ =C-d= and =C-c= work as usual.


*** DONE Ponderables [3/3]:

+ [X] does the program quit on /immediate/ reception of a /q/, or until RET is pressed?
*ANSWER*: the terminal is still in canonical mode, therefore inputs are processed only upon receipt of a RET.

+ [X] what happens to the rest of the characters that follow a /q/?
*ANSWER*: these are sent to the terminal after the program has quit, and bash tries to execute them as a command.
#+BEGIN_SRC 
> ./kilo
abcqdef RET
> def
bash: def not found
#+END_SRC

+ [X] how do inputs with a /q/ in them work with =C-c=, =C-d= and =C-z=?
*ANSWER*: Ran testkilo (which echoed each character in the loop body).
   + =C-c= terminates the program without ceremony, there is no input sent to the bash prompt.
   + =C-d= works almost like RET: the following bash prompt receives the remaining characters, but does not execute them. RET is not a character that is passed to the shell prompt, which means in normal termination, RET was processed as a normal character, but also flushed the input. Also, the first character printed was on the same line as input.
   + =C-z= this stops the job and puts in background, =fg= brings it back to foreground; however all the prior input queue is lost ...

#+BEGIN_SRC 
> ./testkilo
abcqdef C-d a
b
c
> def C-c
>
> ./testkilo
abcqdef C-c
>
> ./testkilo
abcqdef C-z
[1]+ Stopped    ./testkilo
> fg
./testkilo
_ 
#+END_SRC

+ [ ] Understand/explain the behaviour of =C-z=.

** Commit 4

+ in this commit, we modify the terminal characteristics to stop it from echoing input.
+ *raw mode* for the terminal as opposed to canonical mode, processes each keypress, does not wait for RET to be pressed for it to be sent to the program.
+ =termios.h= provides a way of capturing and modifying the attributes of the terminal. =man termios.h= is quite enlightening.
+ the attributes of the terminal are captured in a structure, =struct termios=.
  + =tcgetattr(fd_terminal, &target_termios_struct)= retrieves the attributes of the terminal referred to by =fd_terminal=.
  + =tcsetattr(fd_terminal, optional_action, &source_termios_struct)= sets the attribute of the relevant terminal.
+ the termios structure is comprised of a few variables (such as =c_iflag=, =c_oflag=, =c_lflag=, =c_cflag=) each(?) of whose bits represent some attribute of the terminal.
+ by modifying these bits, and pushing them back to the terminal, changes can be effected.
  + the =&= operator performs a bitwise and.
  + the =~= operator performs a bitwise negation.
  + =ECHO= is a bitfield, comprising entirely of 0s except for one bit in question.
  + brevity goes well with sanity, so, say: =1011 & ~(0001)= --> =1011 & 1110= --> =1010=
  + ie, the important bit in =ECHO= has been set to 0 in our target variable.
  + the terminal will now no longer echo the characters typed in it as input (like a password prompt).
+ having modified the struct, we use =tcsetattr= to modify the terminal.
  + =TCSAFLUSH= is one of three optional actions available. With =TCSAFLUSH=, the changes are applied after all output to =fd_terminal= has been transmitted, and any remaining input is discarded.
  + the other optional actions are: =TCSANOW= (apply all changes immediately) and =TCSADRAIN= (apply changes after all output has been written) 
+ after the program ends, the terminal still retains its modification -- the prompt will not echo input.
  + interestingly, the terminal does not respond to =C-l=! (I guess it's just treated as an ASCII character; input =abcq C-l RET= clears the screen)
  + even more interestingly, after having quit the program, RET causes the prompt to be duplicated without a newline ...

#+BEGIN_SRC 
> > > > >
#+END_SRC

+ use the =reset= command to reset the terminal to its usual behaviour.

*** TODO Ponderables [3/5]:

+ [ ] what does =FILENO= signify? what else could it be?
+ [ ] (vague) recall the following problem with login shells (or ssh?): sometimes, there is a noticeable lag between getting logged in and the prompt being available -- I believe this has resulted in passwords being exposed partially and even executed. Maybe this can be set right with some of these flush capabilities provided by termios.h. Document this aberration the next time it happens.
+ [X] (easy) =&== with a bitfield sets the high bits in the operand2 to 0; how does one reverse the operation (ie, the bits that are high in the bitfield must be high in the target variable)?
*ANSWER*: =var |=bitfield=
+ [X] (meta) come up with a better number to illustrate these bitwise operations instead of something arbitrary!
*ANSWER*: let =var = 1010= and =bitfield = 1100=. 
+ [X] what do =var &=bitfield= and =var |=~(bitfield)= do?
*ANSWER*: For the sake of completeness and pattern finding, I shall do all four combinations:
#+BEGIN_SRC 
1010 & 1100 --> 1000
1010 | 1100 --> 1110
1010 & ~(1100) --> 1010 & 0011 --> 0010
1010 | ~(1100) --> 1010 | 0011 --> 1011
#+END_SRC

|------------------+----------------------------------------------------------|
| action           | interpretation                                           |
|------------------+----------------------------------------------------------|
| =a&=b=           | filter the bits that are high in both, set the rest to 0 |
| =a \vert = b=    | set high the high bits in =b=, keep rest unchanged       |
| =a&=~(b)=        | set low the high bits in =b=                             |
| =a \vert = ~(b)= | set high the low bits in =b=, keep rest unchanged        |
|------------------+----------------------------------------------------------|

(I'm still unhappy with the asymmetry).

+ [ ] for what scenarioIn C++ the answer is different, because objects can delete temporary files and so forth in their destructors, so you need to make sure those get called.

 z will the presence/absence of =TCSAFLUSH= modify the program's behaviour?

** Commit 5

+ our next step involves resetting the terminal to its original state when the program exits.
+ to do this, we capture the original state of the terminal in a global struct variable, =original_termios=;
+ inside =enterRawMode= a copy of this variable is created, modified and then applied.
+ a simple function =disableRawMode= to reset the terminal to its original state is written using  =tcsetattr= and =original_termios=.
+ before the program exits, =disableRawMode= ought to be called.
  + my first approach is to call =disableRawMode= once the loop has been broken, ie encountering =C-d= or /q/. It works as expected.
  + unused input queue is *not* sent to the next terminal prompt; I presume this is a consequence of =TCSAFLUSH=.
+ the tutorial uses =atexit= from =stdlib.h= to call =disableRawMode= when the program terminates.
  + =atexit= takes a function pointer as an argument and calls this when the program is being terminated.
  + several =atexit= functions may be registered (upto 32), and these are called in their "order of registration" (what's that?)
  + =atexit()= can be placed anywhere in the program -- in the tutorial, it is placed right inside =enableRawMode= as =atexit(disableRawMode);=.
  + I have chosen not to follow this; I shall disable raw mode before returning from the main.

*** TODO Ponderables [2/5]:

+ [X] what happens when =disableRawMode= is run after =return 0;=?
*ANSWER*: it is not called.

+ [X] how does the program behave with the exit techniques you are aware of?
*ANSWER*: refer to the table below. =nodisable= does not call =disableRawMode= before =return 0;=, =yesdisable= does. the field =echo= documents whether the terminal echoes input after the program has been terminated; =trailing= documents whether remaining elements in the input queue are sent to the prompt after program termination.

|------------+-----------+------+----------|
| program    | input     | echo | trailing |
|------------+-----------+------+----------|
| nodisable  | =abcqdef= | no   | yes      |
| nodisable  | =C-d=     | no   | --       |
| nodisable  | =C-c=     | yes  | --       |
| nodisable  | =C-z=     | yes  | --       |
| yesdisable | =abcqdef= | yes  | no       |
| yesdisable | =C-d=     | yes  | --       |
| yesdisable | =C-c=     | yes  | --       |
| yesdisable | =C-z=     | yes  | --       |
|------------+-----------+------+----------|

+ [ ] what is the difference between simply calling =disableRawMode= before returning from main, and calling it in an =atexit()= context?
*ANSWER*: (incomplete) I suspect it has something to do with the various ways in which a program can be terminated (SIGKILL, SIGTERM etc).
+ [ ] after suspending and bringing this program to the foreground (=C-z=, =fg=); and after terminating with =C-c=, the echo characteristics are restored. Why?
*ANSWER*: (UNSOLVED) I spent a lot of time on this, going through how signals are handled, some kernel source code, and running =strace -p #PID= on my process and observing what happens when =SIGINT/SIGTSTP= are sent. it's worth noting that =read()= is a system call that is being interrupted, and these may be handled differently. my current belief is that the signal handler of something restores sane defaults upon terminating/ resuming the process.

by the way, =strace= is a great tool!

+ [ ] (optional) what is =brk(NULL)= that is seen in the output of =strace=?

** Commit 6


+ in this commit, we try disabling canonical mode.
+ cannonical mode has the following properties (from =man termios=):
  + input is available line by line; and is only processed on RET or EOF.
  + input lines can be edited, by say, backspace
+ the /c_lflag/ =ICANON= can be used to set the terminal to noncanonical mode.
+ in noncanonical mode, input is available immediately without the user having to press RET/EOF
+ line editing is not possible in noncanonical mode; with characters such as =BSPC=, =C-d=, =C-l= not being processed and being printed on screen.
+ =C-c= does work, as usual (I suspect this is because it's handled by a signal handler somewhere).

+ The tutorial proceeds by disabling both echoing and canonical modes; however I have opted not to do the same because echoing is useful to understanding what is happening.
+ =ICANON= is flipped and set.
+ (without diagnostic messages, which I will get to in a bit) One clear consequence of running in noncanonical mode is that pressing =q= /immediately/ terminates the program -- the read loop is not awaiting a RET/EOF to process its input; the /q/ is almost immediately available to the program once it has been pressed.

(note: no diagnostic messages inside loop)
#+BEGIN_SRC 
> ./icanon
blueq >_
#+END_SRC

+ *on diagnostic messages with printf*
  + as in the previous commits, I was printing each character received as a n input using the =printf= command.
  + however, the output of using a =printf= in noncanonical mode was counterintuitive.

I expected the output to be as follows:
#+BEGIN_SRC 
> ./icanon
bblluuee  cchheessee_
#+END_SRC
, which is reasonable because each character must be printed immediately upon receipt, since each character is immediately available upon input.

However, what I observed was the following (with =printf=):
#+BEGIN_SRC 
> ./icanon
blue cheese RET
blue cheese_
#+END_SRC

, which does not look like canonical mode at all.

After some (much) pondering, I realized that the culprit might be =printf=, which is not a system call, and may be behaving in some "wait-until-the-coast-is-clear-way", and that I should look for a syscall equivalent of =read=. 

Cue =write= (=man 2 write=); and now the print diagnostic runs as I expect it to: =bblluueecchheessee_=

This was a cool discovery.

*** DONE Ponderables [3/3]:

+ [X] so what about all those previous diagnostics with =printf=, do you want to do them again? do you expect them to change?
*ANSWER*: "I want to, but I won't, therefore I shan't." (TODO: latinize this)

as to change, I do not expect there to be a lot of change, since the program was running in canonical mode, where the input was not available immediately anyway.

+ [X] why does =printf= behave so?
*ANSWER*: [[https://stackoverflow.com/questions/1716296/why-does-printf-not-flush-after-the-call-unless-a-newline-is-in-the-format-strin][SO: Why does printf not flush unless a newline is in the format string?]]

=stdout= is typically buffered, and prints its output when told to/ when it meets a newline. this /might/ explain some oddities that I might have observed had I persisted with =printf= containing a newline in its output. 

Also worth noting that a newline flushes the buffer only when writing to =stdout=, the buffer is not flushed when writing to a file ...

+ [X] when running with =printf=, RET /does/ cause the inner-loop printing to happen. why?
*ANSWER*: (incomplete) some sort of flushing mechanism? Yes, see answer above.

** Commit 7

+ in this part of the tutorial, we want to display the keys being pressed. The tutorial uses =printf()= to do the job, and the issue of the flushing is cleverly hidden with the formatting string containing a =%d=.
+ I agree that =printf()= is the way to go, since =write= seems to be more unwieldy.
+ we add a header file, =ctypes.h=. this provides functions for determining whether a character is of various types (numeric, alphanumeric, uppercase, lowercase etc); we are interested in using =iscntrl=, which determines if it is a control character.

+ as observed before, keypresses with control in them are not always respected in canonical mode (except for =C-c= and =C-z= which send signals that are handled by ... something, ie not our program).

+ Pressing arrow keys, PgUp, PgDn, Home, End etc produce 3-4 byte outputs. These are called /escape sequences./ They start with a /27/ byte, which is the code for ESC, followed by 91, which is '['.

| input        | output       |
|--------------+--------------|
| ESC          | 27           |
| RET          | 10 (!)       |
| Up           | 27 91 65     |
| Dn           | 27 91 66     |
| Left         | 27 91 68     |
| Right        | 27 91 67     |
| PgUp         | 27 91 53 126 |
| PgDn         | 27 91 54 126 |
| Home         | 27 91 55 126 |
| End          | 27 91 56 126 |
| BSPC         | 127          |
| C-a to C-y * | 1 to 25      |
| C-0 to C-9   | wut          |
|--------------+--------------|

+ +some+ a lot of the control sequences behave unusually (this is apart from =C-c= and =C-z=):
  + =C-s= handles [[https://en.wikipedia.org/wiki/Software_flow_control][software flow control]], which stops transmission of data to the terminal (holding it in a buffer). =C-q= resumes transmission of data, and the characters typed in between are processed in one go.
  + =C-j= and =C-m= output 10, which is RET. this also works in the shell. (see later explanation of these)
  + =C-4= produces the output /Quit/, and the program terminates.
  + =C-0= and =C-1= output the ASCII values of 0 and 1 respectively (48, 49); =C-2= produces 0, =C-9= produces 9
  + =C-8= produces 127 (backspace) (=C-7= works as undo in bash, but not in this program)
  + the rest of the numerals produce values from 27 onwards ...
  + =C-v= works sort of like passthrough mode in bash, but this program does not register it as something special.

*** Ponderables [1/4]:

+ [ ]  how did =write()= know how to format the a /c/ as a character?
*ANSWER*: =write= knows nothing about formatting its output. its prototype is:
=write(filedescriptor, start_address, num_bytes)=

It writes to the location described by the file descriptor, by dumping /num_bytes/ from /start_address/ to it. (if there are fewer than /num_bytes/ available, it transfers that.)

The decision to print as a character/ binary/ hexadecimal etc, is some setting in the terminal emulator, I think.

I should try to print an integer using =write= (4 bytes) and see what the output looks like: I ran a loop until an arbitrarily high integer value, displaying both the integer and what it printed to the screen when written with =write=. A small sample:

#+BEGIN_SRC 
...
AÃ i: 49985
BÃ i: 49986
CÃ i: 49987
DÃ i: 49988
EÃ i: 49989
...
#+END_SRC

It's interesting that the increase is reflected in the character on the left; I suspect this has something to do with endianness. 

+ [ ] why did the test program above show increments by changing the left most character? 

+ [X] =iscntrl()= is supposed to take an integer as an argument, but is okay with receiving a character as its input. what is happening?
*ANSWER*: (solved) +typecasting? am I misunderstanding the way characters and integers are handled/interpreted? is the compiler glossing over this type mismatch?+ 

don't forget that in C, chars are 8bit ints, and types can get promoted up (safely?). This type promotion is something done automatically by the compiler, nothng to worry about.

+ [ ] what on earth is happening with the arbitrary mappings of Control + numerals?!

** Commit 8

+ in this commit, we want to disable our program from being interrupted by signals.
+ =termios.h= provides a way of disabling this: by flipping a certain bit in the /input mode flag/ =c_iflag=. The relevant flag constant is given by =ISIG=.
+ from the man page for termios: /when any of the characters INTR, QUIT, SUSP or DSUSP are received, generate the corresponding signal.
+ INTR: =C-c=, QUIT: =C-\=, SUSP: =C-z=
+ DSUSP is delayed suspend, which waits for the next read cycle to start suspending. This does not work on linux, but exists on Macs as =C-y=

+ disabling =C-s= and =C-q=, the software flow control: can be unset by modifying the =IXON= bit in the =c_iflag= mode. XON/XOFF are the names of =C-q= and =C-s=, standing for transmission ON and transmission OFF.

+ disabling =C-v=, which enables passing values literally. Flip the =IEXTEN= bit in =c_iflag=.
+ =C-v= is called LNEXT or literal next. to pass =C-c= to the process instead of invoking the signal handler, press =C-v C-c=. (=C-v= did nothing in my program before I disabled it ...)
+ =IEXTEN=: Enable implementation-defined input processing. This flag, as well as =ICANON= must be enabled for the special characters EOL2, LNEXT, WERASE to be interpreted, and for the IUCLC flag to be effective.
  + I don't understand what any of this says.
  + EOL and EOL2 are additional characters that can behave like newlines. These are usually undefined and rarely used (an exception being telnet, where =~= / =C-]= are alternate characters.
  + WERASE is word erase; erases to the end of the previous word
  + IUCLC -- maps upper case to lower case on input


+ =C-m= produces a 10, which is RET; =C-j= also produces a 10 (which is also in line with what control+alphabets are supposed to do)
+ =C-m= produces a carriage return, '\r'; which the terminal reinterprets as new line. Carriage return (CR) brings the cursor back to the start of the line.
+ note that the distinction between newline and carriage return has been melded over the years.
+ the terminal helpfully converts the carriage return to the new line; this can be fixed by setting the =ICRNL= bit in =c_iflag= which results in =C-m= printing as 13, as it ough to.

*** TODO Ponderables [2/3]:

+ [ ] write a signal handler; instead of blocking all signals.

+ [X] why does =C-v= not work in my program even without disabling =IEXTEN=?
*ANSWER*: LNEXT is interpreted only in canonical mode.

+ [X] so apparently, RET is ASCII 13 and not 10. for some reason, the program was displaying a 10 all this while; disabling ICRNL, led to RET becoming 13. what's happening?
*ANSWER*: I believe this has to do with the gradual semantic blending of newline and carriage return. this must have something to do with teletype legacy. anyway, =C-m= is 13 (newline) and =C-j= is RET.
