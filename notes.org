#+TITLE: Notes on Building a Texteditor

* Notes

** Commit 1

+ created =main=.
+ compiled using a Makefile. Makefiles help automate the process of compilation; simply running =./make= in the folder containing the Makefile will compile according to specifications.
#+BEGIN_SRC 
kilo.c: kilo
    $(CC) kilo.c -o kilo -Wall -Wextra -pedantic -std=c99
#+END_SRC
+ the final executable is in a file named /kilo/; running =./kilo= yields nothing, however the final return value can be checked in the shell by running =echo $?=.

*** TODO Ponderables [0/2]:

+ [ ] how are Makefiles structured? (what is meant by =kilo.c: kilo= etc.)
+ [ ] what is =?= in the shell?
+ [ ] how are commit messages displayed in git, and on the Github site?

** Commit 2

+ this commit is going to continuously read characters from the terminal's input.
+ the prototype of =read= is:
#+BEGIN_SRC C
ssize_t read (int file_descriptor, void *buffer, size_t nbytes);
#+END_SRC

  + read =nbytes= bytes from =file_descriptor= into the buffer.
  + in general =read=, can read from files, with offsets etc. see =man 3 read= for more details.
  + the value returned is the number of bytes read -- is less that =nbytes=, in case the file/pipe has fewer bytes than is requested.
  + in our case, a successful read will have read a single byte, thus returning 1.

  + The current mode in the terminal is *canonical/cooked* mode. Keyboard input is sent to the terminal only upon hitting Return.
  + This allows for editing with Backspace etc.
  + =C-d= and =C-c= help terminate the program. =C-d= sends the program =EOF=, indicating that there are no more bytes to be read. =C-c= terminates the process immediately.
  + =unistd.h= provides =read= and =STDIN_FILENO=

*** TODO Ponderables [2/2]:

+ [X] what exactly is happening when several letters are sent to the program after pressing Return? (in Canonical mode, that is)?
*ANSWER*: I tested it out by making the loop echo back the input characters. the output is as follows:

+ [X] =STDIN_FILENO=. What is it?
*ANSWER*: I made the test program print out its value -- it was 0. =unistd.h= defines it to be 0, along with =STDOUT_FILENO=(1) and =STDERR_FILENO=(2).

#+BEGIN_SRC 
> ./testkilo
abcd RET
a
b
c
d

_
#+END_SRC

** Commit 3

+ *raw mode* for the terminal as opposed to canonical mode, processes each keypress, does not wait for RET to be pressed for it to be sent to the program.
+ this commit has the loop modified to quit upon pressing =q=. simple enough.
+ =C-d= and =C-c= work as usual.


*** TODO Ponderables [3/3]:

+ [X] does the program quit on /immediate/ reception of a /q/, or until RET is pressed?
*ANSWER*: the terminal is still in canonical mode, therefore inputs are processed only upon receipt of a RET.

+ [X] what happens to the rest of the characters that follow a /q/?
*ANSWER*: these are sent to the terminal after the program has quit, and bash tries to execute them as a command.
#+BEGIN_SRC 
> ./kilo
abcqdef RET
> def
bash: def not found
#+END_SRC

+ [X] how do inputs with a /q/ in them work with =C-c=, =C-d= and =C-z=?
*ANSWER*: Ran testkilo (which echoed each character in the loop body).
   + =C-c= terminates the program without ceremony, there is no input sent to the bash prompt.
   + =C-d= works almost like RET: the following bash prompt receives the remaining characters, but does not execute them. RET is not a character that is passed to the shell prompt, which means in normal termination, RET was processed as a normal character, but also flushed the input. Also, the first character printed was on the same line as input.
   + =C-z= this stops the job and puts in background, =fg= brings it back to foreground; however all the prior input queue is lost ...

#+BEGIN_SRC 
> ./testkilo
abcqdef C-d a
b
c
> def C-c
>
> ./testkilo
abcqdef C-c
>
> ./testkilo
abcqdef C-z
[1]+ Stopped    ./testkilo
> fg
./testkilo
_ 
#+END_SRC

+ [ ] Understand/explain the behaviour of =C-z=.
