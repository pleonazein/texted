#+TITLE: Notes on Building a Texteditor

* Notes

** Commit 1

+ created =main=.
+ compiled using a Makefile. Makefiles help automate the process of compilation; simply running =./make= in the folder containing the Makefile will compile according to specifications.
#+BEGIN_SRC 
kilo.c: kilo
    $(CC) kilo.c -o kilo -Wall -Wextra -pedantic -std=c99
#+END_SRC
+ the final executable is in a file named /kilo/; running =./kilo= yields nothing, however the final return value can be checked in the shell by running =echo $?=.

*** TODO Ponderables [0/2]:

+ [ ] how are Makefiles structured? (what is meant by =kilo.c: kilo= etc.)
+ [ ] what is =?= in the shell?
+ [ ] how are commit messages displayed in git, and on the Github site?

** Commit 2

+ this commit is going to continuously read characters from the terminal's input.
+ the prototype of =read= is:
#+BEGIN_SRC C
ssize_t read (int file_descriptor, void *buffer, size_t nbytes);
#+END_SRC

  + read =nbytes= bytes from =file_descriptor= into the buffer.
  + in general =read=, can read from files, with offsets etc. see =man 3 read= for more details.
  + the value returned is the number of bytes read -- is less that =nbytes=, in case the file/pipe has fewer bytes than is requested.
  + in our case, a successful read will have read a single byte, thus returning 1.

  + The current mode in the terminal is *canonical/cooked* mode. Keyboard input is sent to the terminal only upon hitting RET or =C-d= (EOF).
  + This allows for editing with Backspace etc.
  + =C-d= and =C-c= help terminate the program. =C-d= sends the program =EOF=, indicating that there are no more bytes to be read. =C-c= terminates the process immediately.
  + =unistd.h= provides =read= and =STDIN_FILENO=

*** DONE Ponderables [2/2]:

+ [X] what exactly is happening when several letters are sent to the program after pressing Return? (in Canonical mode, that is)?
*ANSWER*: I tested it out by making the loop echo back the input characters. the output is as follows:

+ [X] =STDIN_FILENO=. What is it?
*ANSWER*: I made the test program print out its value -- it was 0. =unistd.h= defines it to be 0, along with =STDOUT_FILENO=(1) and =STDERR_FILENO=(2).

#+BEGIN_SRC 
> ./testkilo
abcd RET
a
b
c
d

_
#+END_SRC

** Commit 3

+ this commit has the loop modified to quit upon pressing =q=. simple enough.
+ =C-d= and =C-c= work as usual.


*** DONE Ponderables [3/3]:

+ [X] does the program quit on /immediate/ reception of a /q/, or until RET is pressed?
*ANSWER*: the terminal is still in canonical mode, therefore inputs are processed only upon receipt of a RET.

+ [X] what happens to the rest of the characters that follow a /q/?
*ANSWER*: these are sent to the terminal after the program has quit, and bash tries to execute them as a command.
#+BEGIN_SRC 
> ./kilo
abcqdef RET
> def
bash: def not found
#+END_SRC

+ [X] how do inputs with a /q/ in them work with =C-c=, =C-d= and =C-z=?
*ANSWER*: Ran testkilo (which echoed each character in the loop body).
   + =C-c= terminates the program without ceremony, there is no input sent to the bash prompt.
   + =C-d= works almost like RET: the following bash prompt receives the remaining characters, but does not execute them. RET is not a character that is passed to the shell prompt, which means in normal termination, RET was processed as a normal character, but also flushed the input. Also, the first character printed was on the same line as input.
   + =C-z= this stops the job and puts in background, =fg= brings it back to foreground; however all the prior input queue is lost ...

#+BEGIN_SRC 
> ./testkilo
abcqdef C-d a
b
c
> def C-c
>
> ./testkilo
abcqdef C-c
>
> ./testkilo
abcqdef C-z
[1]+ Stopped    ./testkilo
> fg
./testkilo
_ 
#+END_SRC

+ [ ] Understand/explain the behaviour of =C-z=.

** Commit 4

+ in this commit, we modify the terminal characteristics to stop it from echoing input.
+ *raw mode* for the terminal as opposed to canonical mode, processes each keypress, does not wait for RET to be pressed for it to be sent to the program.
+ =termios.h= provides a way of capturing and modifying the attributes of the terminal. =man termios.h= is quite enlightening.
+ the attributes of the terminal are captured in a structure, =struct termios=.
  + =tcgetattr(fd_terminal, &target_termios_struct)= retrieves the attributes of the terminal referred to by =fd_terminal=.
  + =tcsetattr(fd_terminal, optional_action, &source_termios_struct)= sets the attribute of the relevant terminal.
+ the termios structure is comprised of a few variables (such as =c_iflag=, =c_oflag=, =c_lflag=, =c_cflag=) each(?) of whose bits represent some attribute of the terminal.
+ by modifying these bits, and pushing them back to the terminal, changes can be effected.
  + the =&= operator performs a bitwise and.
  + the =~= operator performs a bitwise negation.
  + =ECHO= is a bitfield, comprising entirely of 0s except for one bit in question.
  + brevity goes well with sanity, so, say: =1011 & ~(0001)= --> =1011 & 1110= --> =1010=
  + ie, the important bit in =ECHO= has been set to 0 in our target variable.
  + the terminal will now no longer echo the characters typed in it as input (like a password prompt).
+ having modified the struct, we use =tcsetattr= to modify the terminal.
  + =TCSAFLUSH= is one of three optional actions available. With =TCSAFLUSH=, the changes are applied after all output to =fd_terminal= has been transmitted, and any remaining input is discarded.
  + the other optional actions are: =TCSANOW= (apply all changes immediately) and =TCSADRAIN= (apply changes after all output has been written) 
+ after the program ends, the terminal still retains its modification -- the prompt will not echo input.
  + interestingly, the terminal does not respond to =C-l=! (I guess it's just treated as an ASCII character; input =abcq C-l RET= clears the screen)
  + even more interestingly, after having quit the program, RET causes the prompt to be duplicated without a newline ...

#+BEGIN_SRC 
> > > > >
#+END_SRC

+ use the =reset= command to reset the terminal to its usual behaviour.

*** TODO Ponderables [3/5]:

+ [ ] what does =FILENO= signify? what else could it be?
+ [ ] (vague) recall the following problem with login shells (or ssh?): sometimes, there is a noticeable lag between getting logged in and the prompt being available -- I believe this has resulted in passwords being exposed partially and even executed. Maybe this can be set right with some of these flush capabilities provided by termios.h. Document this aberration the next time it happens.
+ [X] (easy) =&== with a bitfield sets the high bits in the operand2 to 0; how does one reverse the operation (ie, the bits that are high in the bitfield must be high in the target variable)?
*ANSWER*: =var |=bitfield=
+ [X] (meta) come up with a better number to illustrate these bitwise operations instead of something arbitrary!
*ANSWER*: let =var = 1010= and =bitfield = 1100=. 
+ [X] what do =var &=bitfield= and =var |=~(bitfield)= do?
*ANSWER*: For the sake of completeness and pattern finding, I shall do all four combinations:
#+BEGIN_SRC 
1010 & 1100 --> 1000
1010 | 1100 --> 1110
1010 & ~(1100) --> 1010 & 0011 --> 0010
1010 | ~(1100) --> 1010 | 0011 --> 1011
#+END_SRC

|------------------+----------------------------------------------------------|
| action           | interpretation                                           |
|------------------+----------------------------------------------------------|
| =a&=b=           | filter the bits that are high in both, set the rest to 0 |
| =a \vert = b=    | set high the high bits in =b=, keep rest unchanged       |
| =a&=~(b)=        | set low the high bits in =b=                             |
| =a \vert = ~(b)= | set high the low bits in =b=, keep rest unchanged        |
|------------------+----------------------------------------------------------|9
(I'm still unhappy with the asymmetry).

+ [ ] for what scenarioIn C++ the answer is different, because objects can delete temporary files and so forth in their destructors, so you need to make sure those get called.

 z will the presence/absence of =TCSAFLUSH= modify the program's behaviour?

** Commit 5

+ our next step involves resetting the terminal to its original state when the program exits.
+ to do this, we capture the original state of the terminal in a global struct variable, =original_termios=;
+ inside =enterRawMode= a copy of this variable is created, modified and then applied.
+ a simple function =disableRawMode= to reset the terminal to its original state is written using  =tcsetattr= and =original_termios=.
+ before the program exits, =disableRawMode= ought to be called.
  + my first approach is to call =disableRawMode= once the loop has been broken, ie encountering =C-d= or /q/. It works as expected.
  + unused input queue is *not* sent to the next terminal prompt; I presume this is a consequence of =TCSAFLUSH=.
+ the tutorial uses =atexit= from =stdlib.h= to call =disableRawMode= when the program terminates.
  + =atexit= takes a function pointer as an argument and calls this when the program is being terminated.
  + several =atexit= functions may be registered (upto 32), and these are called in their "order of registration" (what's that?)
  + =atexit()= can be placed anywhere in the program -- in the tutorial, it is placed right inside =enableRawMode= as =atexit(disableRawMode);=.
  + I have chosen not to follow this; I shall disable raw mode before returning from the main.

*** TODO Ponderables [2/5]:

+ [X] what happens when =disableRawMode= is run after =return 0;=?
*ANSWER*: it is not called.

+ [X] how does the program behave with the exit techniques you are aware of?
*ANSWER*: refer to the table below. =nodisable= does not call =disableRawMode= before =return 0;=, =yesdisable= does. the field =echo= documents whether the terminal echoes input after the program has been terminated; =trailing= documents whether remaining elements in the input queue are sent to the prompt after program termination.

|------------+-----------+------+----------|
| program    | input     | echo | trailing |
|------------+-----------+------+----------|
| nodisable  | =abcqdef= | no   | yes      |
| nodisable  | =C-d=     | no   | --       |
| nodisable  | =C-c=     | yes  | --       |
| nodisable  | =C-z=     | yes  | --       |
| yesdisable | =abcqdef= | yes  | no       |
| yesdisable | =C-d=     | yes  | --       |
| yesdisable | =C-c=     | yes  | --       |
| yesdisable | =C-z=     | yes  | --       |
|------------+-----------+------+----------|

+ [ ] what is the difference between simply calling =disableRawMode= before returning from main, and calling it in an =atexit()= context?
*ANSWER*: (incomplete) I suspect it has something to do with the various ways in which a program can be terminated (SIGKILL, SIGTERM etc).
+ [ ] after suspending and bringing this program to the foreground (=C-z=, =fg=); and after terminating with =C-c=, the echo characteristics are restored. Why?
*ANSWER*: (UNSOLVED) I spent a lot of time on this, going through how signals are handled, some kernel source code, and running =strace -p #PID= on my process and observing what happens when =SIGINT/SIGTSTP= are sent. it's worth noting that =read()= is a system call that is being interrupted, and these may be handled differently. my current belief is that the signal handler of something restores sane defaults upon terminating/ resuming the process.

by the way, =strace= is a great tool!

+ [ ] (optional) what is =brk(NULL)= that is seen in the output of =strace=?
