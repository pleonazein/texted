#+TITLE: Notes on Building a Texteditor

* Notes

** Commit 1

+ created =main=.
+ compiled using a Makefile. Makefiles help automate the process of compilation; simply running =./make= in the folder containing the Makefile will compile according to specifications.
#+BEGIN_SRC 
kilo.c: kilo
    $(CC) kilo.c -o kilo -Wall -Wextra -pedantic -std=c99
#+END_SRC
+ the final executable is in a file named /kilo/; running =./kilo= yields nothing, however the final return value can be checked in the shell by running =echo $?=.

*** TODO Ponderables [0/2]:

+ [ ] how are Makefiles structured? (what is meant by =kilo.c: kilo= etc.)
+ [ ] what is =?= in the shell?
+ [ ] how are commit messages displayed in git, and on the Github site?

** Commit 2

+ this commit is going to continuously read characters from the terminal's input.
+ the prototype of =read= is:
#+BEGIN_SRC C
ssize_t read (int file_descriptor, void *buffer, size_t nbytes);
#+END_SRC

  + read =nbytes= bytes from =file_descriptor= into the buffer.
  + in general =read=, can read from files, with offsets etc. see =man 3 read= for more details.
  + the value returned is the number of bytes read -- is less that =nbytes=, in case the file/pipe has fewer bytes than is requested.
  + in our case, a successful read will have read a single byte, thus returning 1.

  + The current mode in the terminal is *canonical/cooked* mode. Keyboard input is sent to the terminal only upon hitting Return.
  + This allows for editing with Backspace etc.
  + =C-d= and =C-c= help terminate the program. =C-d= sends the program =EOF=, indicating that there are no more bytes to be read. =C-c= terminates the process immediately.
  + =unistd.h= provides =read= and =STDIN_FILENO=

*** TODO Ponderables [2/2]:

+ [X] what exactly is happening when several letters are sent to the program after pressing Return? (in Canonical mode, that is)?
*ANSWER*: I tested it out by making the loop echo back the input characters. the output is as follows:

+ [X] =STDIN_FILENO=. What is it?
*ANSWER*: I made the test program print out its value -- it was 0. =unistd.h= defines it to be 0, along with =STDOUT_FILENO=(1) and =STDERR_FILENO=(2).

#+BEGIN_SRC 
> ./testkilo
abcd RET
a
b
c
d

_
#+END_SRC

** Commit 3

+ this commit has the loop modified to quit upon pressing =q=. simple enough.
+ =C-d= and =C-c= work as usual.


*** TODO Ponderables [3/3]:

+ [X] does the program quit on /immediate/ reception of a /q/, or until RET is pressed?
*ANSWER*: the terminal is still in canonical mode, therefore inputs are processed only upon receipt of a RET.

+ [X] what happens to the rest of the characters that follow a /q/?
*ANSWER*: these are sent to the terminal after the program has quit, and bash tries to execute them as a command.
#+BEGIN_SRC 
> ./kilo
abcqdef RET
> def
bash: def not found
#+END_SRC

+ [X] how do inputs with a /q/ in them work with =C-c=, =C-d= and =C-z=?
*ANSWER*: Ran testkilo (which echoed each character in the loop body).
   + =C-c= terminates the program without ceremony, there is no input sent to the bash prompt.
   + =C-d= works almost like RET: the following bash prompt receives the remaining characters, but does not execute them. RET is not a character that is passed to the shell prompt, which means in normal termination, RET was processed as a normal character, but also flushed the input. Also, the first character printed was on the same line as input.
   + =C-z= this stops the job and puts in background, =fg= brings it back to foreground; however all the prior input queue is lost ...

#+BEGIN_SRC 
> ./testkilo
abcqdef C-d a
b
c
> def C-c
>
> ./testkilo
abcqdef C-c
>
> ./testkilo
abcqdef C-z
[1]+ Stopped    ./testkilo
> fg
./testkilo
_ 
#+END_SRC

+ [ ] Understand/explain the behaviour of =C-z=.

** Commit 4

+ *raw mode* for the terminal as opposed to canonical mode, processes each keypress, does not wait for RET to be pressed for it to be sent to the program.
+ =termios.h= provides a way of capturing and modifying the attributes of the terminal. =man termios.h= is quite enlightening.
+ the attributes of the terminal are captured in a structure, =struct termios=.
  + =tcgetattr(fd_terminal, &target_termios_struct)= retrieves the attributes of the terminal referred to by =fd_terminal=.
  + =tcsetattr(fd_terminal, optional_action, &source_termios_struct)= sets the attribute of the relevant terminal.
+ the termios structure is comprised of a few variables (such as =c_iflag=, =c_oflag=, =c_lflag=, =c_cflag=) each(?) of whose bits represent some attribute of the terminal.
+ by modifying these bits, and pushing them back to the terminal, changes can be effected.
  + the =&= operator performs a bitwise and.
  + the =~= operator performs a bitwise negation.
  + =ECHO= is a bitfield, comprising entirely of 0s except for one bit in question.
  + brevity goes well with sanity, so, say: =1011 & ~(0001)= --> =1011 & 1110= --> =1010=
  + ie, the important bit in =ECHO= has been set to 0 in our target variable.
  + the terminal will now no longer echo the characters typed in it as input (like a password prompt).
+ having modified the struct, we use =tcsetattr= to modify the terminal.
  + =TCSAFLUSH= is one of three optional actions available. With =TCSAFLUSH=, the changes are applied after all output to =fd_terminal= has been transmitted, and any remaining input is discarded.
  + the other optional actions are: =TCSANOW= (apply all changes immediately) and =TCSADRAIN= (apply changes after all output has been written) 
+ after the program ends, the terminal still retains its modification -- the prompt will not echo input.
  + interestingly, the terminal does not respond to =C-l=! (I guess it's just treated as an ASCII character; input =abcq C-l RET= clears the screen)
  + even more interestingly, after having quit the program, RET causes the prompt to be duplicated without a newline ...

#+BEGIN_SRC 
> > > > >
#+END_SRC

+ use the =reset= command to reset the terminal to its usual behaviour.

*** Ponderables [3/5]:

+ [ ] what does =FILENO= signify? what else could it be?
+ [ ] (vague) recall the following problem with login shells (or ssh?): sometimes, there is a noticeable lag between getting logged in and the prompt being available -- I believe this has resulted in passwords being exposed partially and even executed. Maybe this can be set right with some of these flush capabilities provided by termios.h. Document this aberration the next time it happens.
+ [X] (easy) =&== with a bitfield sets the high bits in the operand2 to 0; how does one reverse the operation (ie, the bits that are high in the bitfield must be high in the target variable)?
*ANSWER*: =var |=bitfield=
+ [X] (meta) come up with a better number to illustrate these bitwise operations instead of something arbitrary!
*ANSWER*: let =var = 1010= and =bitfield = 1100=. 
+ [X] what do =var &=bitfield= and =var |=~(bitfield)= do?
*ANSWER*: For the sake of completeness and pattern finding, I shall do all four combinations:
#+BEGIN_SRC 
1010 & 1100 --> 1000
1010 | 1100 --> 1110
1010 & ~(1100) --> 1010 & 0011 --> 0010
1010 | ~(1100) --> 1010 | 0011 --> 1011
#+END_SRC

|------------------+----------------------------------------------------------|
| action           | interpretation                                           |
|------------------+----------------------------------------------------------|
| =a&=b=           | filter the bits that are high in both, set the rest to 0 |
| =a \vert = b=    | set high the high bits in =b=, keep rest unchanged       |
| =a&=~(b)=        | set low the high bits in =b=                             |
| =a \vert = ~(b)= | set high the low bits in =b=, keep rest unchanged        |
|------------------+----------------------------------------------------------|
(I'm still unhappy with the asymmetry).

+ [ ] for what scenario will the presence/absence of =TCSAFLUSH= modify the program's behaviour?

** 
