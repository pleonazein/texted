#+TITLE: Notes on Building a Texteditor

* Notes

** Commit 1

+ created =main=.
+ compiled using a Makefile. Makefiles help automate the process of compilation; simply running =./make= in the folder containing the Makefile will compile according to specifications.
#+BEGIN_SRC 
kilo.c: kilo
    $(CC) kilo.c -o kilo -Wall -Wextra -pedantic -std=c99
#+END_SRC
+ the final executable is in a file named /kilo/; running =./kilo= yields nothing, however the final return value can be checked in the shell by running =echo $?=.

*** TODO Ponderables [0/2]:

+ [ ] how are Makefiles structured? (what is meant by =kilo.c: kilo= etc.)
+ [ ] what is =?= in the shell?
+ [ ] how are commit messages displayed in git, and on the Github site?

** Commit 2

+ this commit is going to continuously read characters from the terminal's input.
+ the prototype of =read= is:
#+BEGIN_SRC C
ssize_t read (int file_descriptor, void *buffer, size_t nbytes);
#+END_SRC

  + read =nbytes= bytes from =file_descriptor= into the buffer.
  + in general =read=, can read from files, with offsets etc. see =man 3 read= for more details.
  + the value returned is the number of bytes read -- is less that =nbytes=, in case the file/pipe has fewer bytes than is requested.
  + in our case, a successful read will have read a single byte, thus returning 1.

  + The current mode in the terminal is *canonical/cooked* mode. Keyboard input is sent to the terminal only upon hitting RET or =C-d= (EOF).
  + This allows for editing with Backspace etc.
  + =C-d= and =C-c= help terminate the program. =C-d= sends the program =EOF=, indicating that there are no more bytes to be read. =C-c= terminates the process immediately.
  + =unistd.h= provides =read= and =STDIN_FILENO=

*** DONE Ponderables [2/2]:

+ [X] what exactly is happening when several letters are sent to the program after pressing Return? (in Canonical mode, that is)?
*ANSWER*: I tested it out by making the loop echo back the input characters. the output is as follows:

+ [X] =STDIN_FILENO=. What is it?
*ANSWER*: I made the test program print out its value -- it was 0. =unistd.h= defines it to be 0, along with =STDOUT_FILENO=(1) and =STDERR_FILENO=(2).

#+BEGIN_SRC 
> ./testkilo
abcd RET
a
b
c
d

_
#+END_SRC

** Commit 3

+ this commit has the loop modified to quit upon pressing =q=. simple enough.
+ =C-d= and =C-c= work as usual.


*** DONE Ponderables [3/3]:

+ [X] does the program quit on /immediate/ reception of a /q/, or until RET is pressed?
*ANSWER*: the terminal is still in canonical mode, therefore inputs are processed only upon receipt of a RET.

+ [X] what happens to the rest of the characters that follow a /q/?
*ANSWER*: these are sent to the terminal after the program has quit, and bash tries to execute them as a command.
#+BEGIN_SRC 
> ./kilo
abcqdef RET
> def
bash: def not found
#+END_SRC

+ [X] how do inputs with a /q/ in them work with =C-c=, =C-d= and =C-z=?
*ANSWER*: Ran testkilo (which echoed each character in the loop body).
   + =C-c= terminates the program without ceremony, there is no input sent to the bash prompt.
   + =C-d= works almost like RET: the following bash prompt receives the remaining characters, but does not execute them. RET is not a character that is passed to the shell prompt, which means in normal termination, RET was processed as a normal character, but also flushed the input. Also, the first character printed was on the same line as input.
   + =C-z= this stops the job and puts in background, =fg= brings it back to foreground; however all the prior input queue is lost ...

#+BEGIN_SRC 
> ./testkilo
abcqdef C-d a
b
c
> def C-c
>
> ./testkilo
abcqdef C-c
>
> ./testkilo
abcqdef C-z
[1]+ Stopped    ./testkilo
> fg
./testkilo
_ 
#+END_SRC

+ [ ] Understand/explain the behaviour of =C-z=.

** Commit 4

+ in this commit, we modify the terminal characteristics to stop it from echoing input.
+ *raw mode* for the terminal as opposed to canonical mode, processes each keypress, does not wait for RET to be pressed for it to be sent to the program.
+ =termios.h= provides a way of capturing and modifying the attributes of the terminal. =man termios.h= is quite enlightening.
+ the attributes of the terminal are captured in a structure, =struct termios=.
  + =tcgetattr(fd_terminal, &target_termios_struct)= retrieves the attributes of the terminal referred to by =fd_terminal=.
  + =tcsetattr(fd_terminal, optional_action, &source_termios_struct)= sets the attribute of the relevant terminal.
+ the termios structure is comprised of a few variables (such as =c_iflag=, =c_oflag=, =c_lflag=, =c_cflag=) each(?) of whose bits represent some attribute of the terminal.
+ by modifying these bits, and pushing them back to the terminal, changes can be effected.
  + the =&= operator performs a bitwise and.
  + the =~= operator performs a bitwise negation.
  + =ECHO= is a bitfield, comprising entirely of 0s except for one bit in question.
  + brevity goes well with sanity, so, say: =1011 & ~(0001)= --> =1011 & 1110= --> =1010=
  + ie, the important bit in =ECHO= has been set to 0 in our target variable.
  + the terminal will now no longer echo the characters typed in it as input (like a password prompt).
+ having modified the struct, we use =tcsetattr= to modify the terminal.
  + =TCSAFLUSH= is one of three optional actions available. With =TCSAFLUSH=, the changes are applied after all output to =fd_terminal= has been transmitted, and any remaining input is discarded.
  + the other optional actions are: =TCSANOW= (apply all changes immediately) and =TCSADRAIN= (apply changes after all output has been written) 
+ after the program ends, the terminal still retains its modification -- the prompt will not echo input.
  + interestingly, the terminal does not respond to =C-l=! (I guess it's just treated as an ASCII character; input =abcq C-l RET= clears the screen)
  + even more interestingly, after having quit the program, RET causes the prompt to be duplicated without a newline ...

#+BEGIN_SRC 
> > > > >
#+END_SRC

+ use the =reset= command to reset the terminal to its usual behaviour.

*** TODO Ponderables [3/5]:

+ [ ] what does =FILENO= signify? what else could it be?
+ [ ] (vague) recall the following problem with login shells (or ssh?): sometimes, there is a noticeable lag between getting logged in and the prompt being available -- I believe this has resulted in passwords being exposed partially and even executed. Maybe this can be set right with some of these flush capabilities provided by termios.h. Document this aberration the next time it happens.
+ [X] (easy) =&== with a bitfield sets the high bits in the operand2 to 0; how does one reverse the operation (ie, the bits that are high in the bitfield must be high in the target variable)?
*ANSWER*: =var |=bitfield=
+ [X] (meta) come up with a better number to illustrate these bitwise operations instead of something arbitrary!
*ANSWER*: let =var = 1010= and =bitfield = 1100=. 
+ [X] what do =var &=bitfield= and =var |=~(bitfield)= do?
*ANSWER*: For the sake of completeness and pattern finding, I shall do all four combinations:
#+BEGIN_SRC 
1010 & 1100 --> 1000
1010 | 1100 --> 1110
1010 & ~(1100) --> 1010 & 0011 --> 0010
1010 | ~(1100) --> 1010 | 0011 --> 1011
#+END_SRC

|------------------+----------------------------------------------------------|
| action           | interpretation                                           |
|------------------+----------------------------------------------------------|
| =a&=b=           | filter the bits that are high in both, set the rest to 0 |
| =a \vert = b=    | set high the high bits in =b=, keep rest unchanged       |
| =a&=~(b)=        | set low the high bits in =b=                             |
| =a \vert = ~(b)= | set high the low bits in =b=, keep rest unchanged        |
|------------------+----------------------------------------------------------|

(I'm still unhappy with the asymmetry).

+ [ ] for what scenarioIn C++ the answer is different, because objects can delete temporary files and so forth in their destructors, so you need to make sure those get called.

 z will the presence/absence of =TCSAFLUSH= modify the program's behaviour?

** Commit 5

+ our next step involves resetting the terminal to its original state when the program exits.
+ to do this, we capture the original state of the terminal in a global struct variable, =original_termios=;
+ inside =enterRawMode= a copy of this variable is created, modified and then applied.
+ a simple function =disableRawMode= to reset the terminal to its original state is written using  =tcsetattr= and =original_termios=.
+ before the program exits, =disableRawMode= ought to be called.
  + my first approach is to call =disableRawMode= once the loop has been broken, ie encountering =C-d= or /q/. It works as expected.
  + unused input queue is *not* sent to the next terminal prompt; I presume this is a consequence of =TCSAFLUSH=.
+ the tutorial uses =atexit= from =stdlib.h= to call =disableRawMode= when the program terminates.
  + =atexit= takes a function pointer as an argument and calls this when the program is being terminated.
  + several =atexit= functions may be registered (upto 32), and these are called in their "order of registration" (what's that? I think these functions are registered in the order in which they are encountered in program flow; implying it is possible that some atexit functions may not be called at all by not traversing the branch in which it is defined.)
  + =atexit()= can be placed anywhere in the program -- in the tutorial, it is placed right inside =enableRawMode= as =atexit(disableRawMode);=.
  + I have chosen not to follow this; I shall disable raw mode before returning from the main.

*** TODO Ponderables [2/5]:

+ [X] what happens when =disableRawMode= is run after =return 0;=?
*ANSWER*: it is not called.

+ [X] how does the program behave with the exit techniques you are aware of?
*ANSWER*: refer to the table below. =nodisable= does not call =disableRawMode= before =return 0;=, =yesdisable= does. the field =echo= documents whether the terminal echoes input after the program has been terminated; =trailing= documents whether remaining elements in the input queue are sent to the prompt after program termination.

|------------+-----------+------+----------|
| program    | input     | echo | trailing |
|------------+-----------+------+----------|
| nodisable  | =abcqdef= | no   | yes      |
| nodisable  | =C-d=     | no   | --       |
| nodisable  | =C-c=     | yes  | --       |
| nodisable  | =C-z=     | yes  | --       |
| yesdisable | =abcqdef= | yes  | no       |
| yesdisable | =C-d=     | yes  | --       |
| yesdisable | =C-c=     | yes  | --       |
| yesdisable | =C-z=     | yes  | --       |
|------------+-----------+------+----------|

+ [ ] what is the difference between simply calling =disableRawMode= before returning from main, and calling it in an =atexit()= context?
*ANSWER*: (incomplete) I suspect it has something to do with the various ways in which a program can be terminated (SIGKILL, SIGTERM etc).
+ [ ] after suspending and bringing this program to the foreground (=C-z=, =fg=); and after terminating with =C-c=, the echo characteristics are restored. Why?
*ANSWER*: (UNSOLVED) I spent a lot of time on this, going through how signals are handled, some kernel source code, and running =strace -p #PID= on my process and observing what happens when =SIGINT/SIGTSTP= are sent. it's worth noting that =read()= is a system call that is being interrupted, and these may be handled differently. my current belief is that the signal handler of something restores sane defaults upon terminating/ resuming the process.

by the way, =strace= is a great tool!

+ [ ] (optional) what is =brk(NULL)= that is seen in the output of =strace=?

** Commit 6


+ in this commit, we try disabling canonical mode.
+ cannonical mode has the following properties (from =man termios=):
  + input is available line by line; and is only processed on RET or EOF.
  + input lines can be edited, by say, backspace
+ the /c_lflag/ =ICANON= can be used to set the terminal to noncanonical mode.
+ in noncanonical mode, input is available immediately without the user having to press RET/EOF
+ line editing is not possible in noncanonical mode; with characters such as =BSPC=, =C-d=, =C-l= not being processed and being printed on screen.
+ =C-c= does work, as usual (I suspect this is because it's handled by a signal handler somewhere).

+ The tutorial proceeds by disabling both echoing and canonical modes; however I have opted not to do the same because echoing is useful to understanding what is happening.
+ =ICANON= is flipped and set.
+ (without diagnostic messages, which I will get to in a bit) One clear consequence of running in noncanonical mode is that pressing =q= /immediately/ terminates the program -- the read loop is not awaiting a RET/EOF to process its input; the /q/ is almost immediately available to the program once it has been pressed.

(note: no diagnostic messages inside loop)
#+BEGIN_SRC 
> ./icanon
blueq >_
#+END_SRC

+ *on diagnostic messages with printf*
  + as in the previous commits, I was printing each character received as a n input using the =printf= command.
  + however, the output of using a =printf= in noncanonical mode was counterintuitive.

I expected the output to be as follows:
#+BEGIN_SRC 
> ./icanon
bblluuee  cchheessee_
#+END_SRC
, which is reasonable because each character must be printed immediately upon receipt, since each character is immediately available upon input.

However, what I observed was the following (with =printf=):
#+BEGIN_SRC 
> ./icanon
blue cheese RET
blue cheese_
#+END_SRC

, which does not look like canonical mode at all.

After some (much) pondering, I realized that the culprit might be =printf=, which is not a system call, and may be behaving in some "wait-until-the-coast-is-clear-way", and that I should look for a syscall equivalent of =read=. 

Cue =write= (=man 2 write=); and now the print diagnostic runs as I expect it to: =bblluueecchheessee_=

This was a cool discovery.

*** DONE Ponderables [3/3]:

+ [X] so what about all those previous diagnostics with =printf=, do you want to do them again? do you expect them to change?
*ANSWER*: "I want to, but I won't, therefore I shan't." (TODO: latinize this)

as to change, I do not expect there to be a lot of change, since the program was running in canonical mode, where the input was not available immediately anyway.

+ [X] why does =printf= behave so?
*ANSWER*: [[https://stackoverflow.com/questions/1716296/why-does-printf-not-flush-after-the-call-unless-a-newline-is-in-the-format-strin][SO: Why does printf not flush unless a newline is in the format string?]]

=stdout= is typically buffered, and prints its output when told to/ when it meets a newline. this /might/ explain some oddities that I might have observed had I persisted with =printf= containing a newline in its output. 

Also worth noting that a newline flushes the buffer only when writing to =stdout=, the buffer is not flushed when writing to a file ...

+ [X] when running with =printf=, RET /does/ cause the inner-loop printing to happen. why?
*ANSWER*: (incomplete) some sort of flushing mechanism? Yes, see answer above.

** Commit 7

+ in this part of the tutorial, we want to display the keys being pressed. The tutorial uses =printf()= to do the job, and the issue of the flushing is cleverly hidden with the formatting string containing a =%d=.
+ I agree that =printf()= is the way to go, since =write= seems to be more unwieldy.
+ we add a header file, =ctypes.h=. this provides functions for determining whether a character is of various types (numeric, alphanumeric, uppercase, lowercase etc); we are interested in using =iscntrl=, which determines if it is a control character.

+ as observed before, keypresses with control in them are not always respected in canonical mode (except for =C-c= and =C-z= which send signals that are handled by ... something, ie not our program).

+ Pressing arrow keys, PgUp, PgDn, Home, End etc produce 3-4 byte outputs. These are called /escape sequences./ They start with a /27/ byte, which is the code for ESC, followed by 91, which is '['.

| input        | output       |
|--------------+--------------|
| ESC          | 27           |
| RET          | 10 (!)       |
| Up           | 27 91 65     |
| Dn           | 27 91 66     |
| Left         | 27 91 68     |
| Right        | 27 91 67     |
| PgUp         | 27 91 53 126 |
| PgDn         | 27 91 54 126 |
| Home         | 27 91 55 126 |
| End          | 27 91 56 126 |
| BSPC         | 127          |
| C-a to C-y * | 1 to 25      |
| C-0 to C-9   | wut          |
|--------------+--------------|

+ +some+ a lot of the control sequences behave unusually (this is apart from =C-c= and =C-z=):
  + =C-s= handles [[https://en.wikipedia.org/wiki/Software_flow_control][software flow control]], which stops transmission of data to the terminal (holding it in a buffer). =C-q= resumes transmission of data, and the characters typed in between are processed in one go.
  + =C-j= and =C-m= output 10, which is RET. this also works in the shell. (see later explanation of these)
  + =C-4= produces the output /Quit/, and the program terminates.
  + =C-0= and =C-1= output the ASCII values of 0 and 1 respectively (48, 49); =C-2= produces 0, =C-9= produces 9
  + =C-8= produces 127 (backspace) (=C-7= works as undo in bash, but not in this program)
  + the rest of the numerals produce values from 27 onwards ...
  + =C-v= works sort of like passthrough mode in bash, but this program does not register it as something special.

*** Ponderables [1/4]:

+ [ ]  how did =write()= know how to format the a /c/ as a character?
*ANSWER*: =write= knows nothing about formatting its output. its prototype is:
=write(filedescriptor, start_address, num_bytes)=

It writes to the location described by the file descriptor, by dumping /num_bytes/ from /start_address/ to it. (if there are fewer than /num_bytes/ available, it transfers that.)

The decision to print as a character/ binary/ hexadecimal etc, is some setting in the terminal emulator, I think.

I should try to print an integer using =write= (4 bytes) and see what the output looks like: I ran a loop until an arbitrarily high integer value, displaying both the integer and what it printed to the screen when written with =write=. A small sample:

#+BEGIN_SRC 
...
AÃ i: 49985
BÃ i: 49986
CÃ i: 49987
DÃ i: 49988
EÃ i: 49989
...
#+END_SRC

It's interesting that the increase is reflected in the character on the left; I suspect this has something to do with endianness. 

+ [ ] why did the test program above show increments by changing the left most character? 

+ [X] =iscntrl()= is supposed to take an integer as an argument, but is okay with receiving a character as its input. what is happening?
*ANSWER*: (solved) +typecasting? am I misunderstanding the way characters and integers are handled/interpreted? is the compiler glossing over this type mismatch?+ 

don't forget that in C, chars are 8bit ints, and types can get promoted up (safely?). This type promotion is something done automatically by the compiler, nothng to worry about.

+ [ ] what on earth is happening with the arbitrary mappings of Control + numerals?!

** Commit 8

+ in this commit, we want to disable our program from being interrupted by signals.
+ =termios.h= provides a way of disabling this: by flipping a certain bit in the /input mode flag/ =c_iflag=. The relevant flag constant is given by =ISIG=.
+ from the man page for termios: /when any of the characters INTR, QUIT, SUSP or DSUSP are received, generate the corresponding signal.
+ INTR: =C-c=, QUIT: =C-\=, SUSP: =C-z=
+ DSUSP is delayed suspend, which waits for the next read cycle to start suspending. This does not work on linux, but exists on Macs as =C-y=

+ disabling =C-s= and =C-q=, the software flow control: can be unset by modifying the =IXON= bit in the =c_iflag= mode. XON/XOFF are the names of =C-q= and =C-s=, standing for transmission ON and transmission OFF.

+ disabling =C-v=, which enables passing values literally. Flip the =IEXTEN= bit in =c_iflag=.
+ =C-v= is called LNEXT or literal next. to pass =C-c= to the process instead of invoking the signal handler, press =C-v C-c=. (=C-v= did nothing in my program before I disabled it ...)
+ =IEXTEN=: Enable implementation-defined input processing. This flag, as well as =ICANON= must be enabled for the special characters EOL2, LNEXT, WERASE to be interpreted, and for the IUCLC flag to be effective.
  + I don't understand what any of this says.
  + EOL and EOL2 are additional characters that can behave like newlines. These are usually undefined and rarely used (an exception being telnet, where =~= / =C-]= are alternate characters.
  + WERASE is word erase; erases to the end of the previous word
  + IUCLC -- maps upper case to lower case on input


+ =C-m= produces a 10, which is RET; =C-j= also produces a 10 (which is also in line with what control+alphabets are supposed to do)
+ =C-m= produces a carriage return, '\r'; which the terminal reinterprets as new line. Carriage return (CR) brings the cursor back to the start of the line.
+ note that the distinction between newline and carriage return has been melded over the years.
+ the terminal helpfully converts the carriage return to the new line; this can be fixed by setting the =ICRNL= bit in =c_iflag= which results in =C-m= printing as 13, as it ough to.

*** TODO Ponderables [2/3]:

+ [ ] write a signal handler; instead of blocking all signals.

+ [X] why does =C-v= not work in my program even without disabling =IEXTEN=?
*ANSWER*: LNEXT is interpreted only in canonical mode.

+ [X] so apparently, RET is ASCII 13 and not 10. for some reason, the program was displaying a 10 all this while; disabling ICRNL, led to RET becoming 13. what's happening?
*ANSWER*: I believe this has to do with the gradual semantic blending of newline and carriage return. this must have something to do with teletype legacy. anyway, =C-m= is 13 (newline) and =C-j= is RET.

** Commit 9

+ in this commit we turn off output processing
+ I understand the distinction between what we did before and now as: input processing is the changes the terminal makes to the input before passing it on to the program; output processing is processing the output of the program so that it appears in a certain way on our terminal
+ better explained by the following example: the terminal translates '\n' to '\r\n'; ie a newline does not just go down to the line below, but resets the cursor to the very start of the line. turning off output processing will disable this behaviour.
+ modifying the =OPOST= bit in the =c_oflag= should do the trick.
+ =OPOST=: perform implementation-defined output processing. disabling this flag will also disable all the other flags in =c_oflag=.

having disabled =OPOST=, the output on pressing keys (here RET) looks like this:

#+BEGIN_SRC 
> ./kilo
13
  13
    13
      13
        13
          _
#+END_SRC

+ actually, the output looks like this regardless of what keys are pressed. This is because the escape sequence in our =printf()= is a newline, '\n'.
+ this is readily remedied by modifying it to '\r\n'.
+ a great mnemonic for remembering '\r\n' is to think of the word /return/ -- 'r' precedes 'n'.


*** DONE Ponderables [1/1]:

+ [X] (fun!) what would happen if I used '\n\r' instead of '\r\n'?
*ANSWER*: since the behaviour is a bit confusing, I first tried replacing '\r\n' with '\r' -- this brings the curson back to the start of the line, and overwrites previous output with new input.

with completely replacing with '\n\r', the behaviour is not the same as the original -- recall that this is because =printf()= buffers its output, and requires a newline ('\n') to flush its output leading to output like the following:

#+BEGIN_SRC 
> ./output_altret
97 ('a')
97 ('a')
13
97 ('a')
        _
#+END_SRC

using an =fflush(stdout)= after printing restores sane behaviour.
(I'm not sure I have explained the above behaviour though ...)

** Commit 10

+ we disable several miscellaneous flags, to achieve that true raw mode ...
+ some of these are hard to explain, and the effects are not very tangible, so I will be brief
  + =BRKINT= (c_iflag): older terminals had a physical BREAK key, which worked like a SIGINT key by sending 0 bits to the terminal driver for specified amounts of time -- this was used to signal the correct baud rate for the terminal ...
  + =INPCK= (c_iflag): input parity check
  + =INSTRIP= (c_iflag): strip bit 8 from input characters. (why was this a thing). okay wow: the original ASCII set was 7-bit, representing 128 possible glyphs; char thus has an extra bit, and this can be stripped ...
  + =CS8= (c_cflag): character size mask (other possible values are CS5,CS6,CS7). I'm not sure what this does, but it might have something to do with alternate definitions of chars, back in the day. since we want to deal with 8-bit chars, we set this flag ON, using the =|== bitfield technique discussed way back.

** Commit 11

+ in this commit we try to make it so that =read()= is not constantly hogging the input.
+ the =c_cc= array of parameters provides two values that help with this.
  + =VTIME=: this specifies a timeout value in deciseconds. if VTIME elapses without any input, =read= returns. (it returns 0 if there is no input, and the given input if there was any)
  + =VMIN=: specifies the minimum number of bytes to be read.

The precise effect of these ought to be considered in the following four cases:

| VMIN | VTIME | effect                      | example            |
|------+-------+-----------------------------+--------------------|
|    0 |     0 | polling read                |                    |
|   >0 |     0 | blocking read               | less               |
|    0 |    >0 | read with timeout           | serial device comm |
|   >0 |    >0 | read with interbyte timeout | vi?                |
|------+-------+-----------------------------+--------------------|

this is quite interesting. the current behaviour of the program is that the =read= command is in the conditional of a while loop. Which implies that it is constantly waiting for an input from the terminal. In some use cases, it may not make sense to hog the I/O of the terminal, for instance, some "animation" may be output to the screen while awaiting for the input; which does not appear to be possible with I/O being blocked by =read=.

the four cases above are described below (source: Kerrisk)

+ *polling read*: if data is available when =read= is called, it returns with either the requested bytes or whatever is available (whichever is lesser). if no input is available, it returns with a 0 (you can see that this is /nonblocking behaviour/ -- =read= is not waiting for input, but returns with a 0).
+ *blocking read*: the terminal expects a minimum number of bytes; and until MIN bytes or the number of bytes requested (whichever is lesser) is received, =read= will block the I/O and returns with the number of bytes read (ie it does not return 0, but waits until a nonzero output is possible). Programs such as =less= have VMIN set to 1, and VTIME set to 0, so that they can wait for a keypress without constantly polling in a loop, which uses the CPU.
+ *read with timeout*: a timer is started when =read= is called, which returns when at least one byte is available, or VTIME deciseconds have elapsed. if nothing has been read, it returns 0. This is useful for talking to a serial device; a timeout can be set to wait for an input, and it prevents hanging in case of a connection timeout.
+ *read with timeout and minimum bytes*: after the first byte is received, a timer is started. the timer is restarted for every subsequent byte received. =read= returns when either the lesser of bytes requested/MIN bytes have been received, or the timer is exhausted. Since the timer is started only when at least one byte has been received, at least one byte is returned. (in this sense, =read= can be blocking, since it can wait indefinitely for that initial input). This is useful in the case of handling /escape sequences/, for example, left is ^[[D, and the program needs to distinguish between such an input generated by pressing the left key and by the user typing it out. Such a distinction can be performed by using a small interbyte timeout, say 0.2s. Depending on the timeout, an escape sequence may be simulated by quickly pressing the component keys. (this is apparently used in some variants of =vi=).

+ the tutorial suggests a value of VMIN = 0 and VTIME = 1 (so like reading from a serial device). this means that it does not wait for a minimum input, but waits only for a maximum time before it returns.

+ the existing loop will not work with these values, and is likely to quit before I get a chance to input. We will modify it.

+ modified program:
  + an infinite loop, =while(1)=
  + a read operation is performed inside the body of the loop
  + the character read is then printed if it's printable, or its decimal notation is outputted (as before)
  + if the character is a 'q', we =break= from the loop.

this works just as before, but there isn't a way of knowing something has changed, so we change the diagnostic message:
+ the char variable =c= is set to '\0' in the body of the loop; which means in case the read times out, there will be a stream of 0s printed out.
+ however, on receipt of input, the character 0 will be replaced by =read= (the assignment to 0 should come before =read= is called), and it is processed/output to the screen as before.

*** TODO Ponderables [1/3]:

+ [ ] why does the tutorial go with VMIN=0 and VTIME=1? this is the serial-modem style of awaiting input, but why?
+ [ ] observe the different parameters and how they affect output.
*ANSWER*: I managed to check that with VMIN set and VTIME set to zero, the behaviour is blocking. the final case I found hard to design observable differences.
maybe I should try to recreate this "hit the keys fast enough to recreate a multibyte keypress"? But how do I detect a key such as Up in the first place? read into an integer?

I have modified the program to read into a 4byte integer; it works as usual for single byte input, but hits a segmentation fault when I press Up, for instance.

+ [X] explain this above segfault.
*ANSWER*: I have fooled around with reading and printing multibyte input to integers with both =read= and =scanf=. it suffices to say that I do not understand anything of what is happening. 

I think I will come back to this later. I shall also abandon the quest for nonzero VMIN/VTIME behaviour, until I understand how to capture multibyte inputs, especially with =read=.
(answered later!)

** Commit 12

+ in this commit we add some error-handling capabilities to our program.
+ the =errno.h= header file provides a number of useful constants for error codes defined up to some POSIX standard.
+ we add =stdlib.h= for =exit()=, which terminates the calling process immediately, closing file descriptors, calling =atexit= registered functions etc. this function takes an integer as its argument, which can be used for further diagnosing the cause of a failed exit.
+ =perror()= is defined in =stdio.h=. It produces a message on standard error describing the last error encountered during a call to a system or library function; when syscalls fail, they return -1 and set the variable =errno= to a value; =perror= takes a string as an argument, and can thus be used to set describe where the error occurred; in addition, it interprets =errno= to a human understandable form. (related, =strerror=)
+ we combine =perror()= and =exit()= in a function =die()= that is called whenever a system call fails. the system calls of interest are =tcgetattr=, =tcsetattr= and =read=. in each case, =perror= is called with the name of the function as a string argument, followed by =exit(1)=. recall that we can investigate values returned using the shell's =echo $?=.
+ while checking whether =read= has occurred successfully, we need to distinguish between =read= returning a zero because of timeout, and the function actually failing.
+ (from =man termios=: "furthermore, if no data is available, POSIX permits a =read(2)= in canonical mode to return either 0, or -1, with =errno= set to =EAGAIN=.
+ =EAGAIN= stands for "Resource unavailable, try again". this is not a fatal error for a polling process, therefore we try to exclude it from hitting the function =die=. in the apt words of @A "this is not really an error worth dying over" (:

*** Ponderables [4/4]:

+ [X] that's all fine and dandy, but how do I generate errors?
*ANSWER*: the book suggests using a pipe or a file as input to the program, so say =echo test_text | ./kilo= and =./kilo < test_file=. as advertised both of these methods fail with the following message:
=tcgetattr() failure: Inappropriate ioctl for device=

+ [ ] what does that mean, "Inappropriate ioctl for device"?
*ANSWER*: I don't know. I searched =errno= for this error, and couldn't find it. I could print the =errno= value to see what is up -- I did, and it's 25. I tried finding the files where these error values are defined (in all error related headers in =/usr/include= and =/usr/include/bits/=) to no avail. Googling suggested that 25 is =ENOTTY=, defined in =man ioctl= as:

#+BEGIN_SRC 
ENOTTY fd is not associated with a character special device.

ENOTTY The specified request does not apply to the kind of object that the file descriptor fd references.
#+END_SRC

Makes sense, even though I don't know the details.

+ [X] how does the program handle holding down a key?
*ANSWER*: this is interesting. at first there is only one keypress registered, followed by 6 zeroes, and then a continuous stream of registered keypresses. sample output upon holding down RET:
#+BEGIN_SRC 
> ./kilo
0
0
0
13
0
0
0
0
0
0
13
13
13
13
13
113 ('q')
> _
#+END_SRC
+ [X] follow up: explain the 6.
*ANSWER*: is this due to =xset= or due to VTIME? changing =xset= because it's easier to change.
#+BEGIN_SRC 
> xset q
...
auto repeat delay: 660 repeat rate: 25
...
> xset r rate 330 25
> ./kilo
0
0
0
13
0
0
0
13
13
13
13
13
113 ('q')
> _
#+END_SRC

in other words, halving the repeat delay halved the number of 0s before which a repeat keypress occurred. that is pretty cool. 

increasing the repeat rate will cause a much larger number of keypresses as I am holding down the keys.

+ [X] (with the default rates) it's rather hard to simulate a continuous keypress. can I improve this by increasing VTIME?
*ANSWER*: changed VTIME to 10 (ie, read timing out only after 1 second). I definitely can type fast enough to simulate a continuous keypress. however, the rate at which 0s are produces is also once a second. holding down a key produces keypresses at the repeat rate.

I also played with the =time= command which breaks down how much of the process time was user time and system time.

** Commit 13

+ first things first: answering the weird segmentation fault when I attempted to read a multibyte keypress into a 4-byte integer. (see ponderable 3 in [[Commit 11]]
+ @A told me the read was supposed to be fine, although, it didn't make sense to store in an integer (he suggested a char array of 4 bytes; more on that later).
+ from the =strace= it appeared as it the segmentation fault occurred due to the read, however, according to @A, =gdb= is the tool of choice for this.
  + to make your program compatible with =gdb= (or at least to get useful line numbers), compile with the =-g= flag.
  + run the program as usual
  + in a new terminal, run =gdb -p $(pregp $nameofyourprogram)=, this opens the =gdb= interface.
  + (btw, the =-tui= flag opens up a primitive TUI)
  + use =c= to continue, =q= to quit
  + learn to use this in greater detail!
+ so, using this, we were able to determine the trouble occurred, passing the integer to =iscntrl()= (which doesn't quite make sense for a multibyte object -- this function is supposed to tell if the character is a control character in the highly limited ASCII charset of 128 characters)
+ although, =iscntrl()= /does/ take an integer for its argument, it doesn't handle all integers: a quick perusal of =man 3 iscntrl= points out helpfully in the description that =these functions check whether c, which must have the value of an unsigned char or EOF, falls into a certain character class ...=.
+ why the =int= then? interesting question.
  + these functions want to handle EOF, which is usually -1. tada


*** META

+ this project has seen a week of regular work! I did have a good time; and these are some good tutorials.
+ of course, realizing that I was a week in, immediately led to two days of inactivity; but that's okay really.
+ I'm also reading some kernel stuff /very, very casually/ on the side.
+ there's a very good chance that both these endeavours die early deaths -- but the nature of /texted/ is that I can easily pick it up again thanks to the tutorial and these notes.
+ (I want to have) *no guilt re: unattempted/incomplete ponderables*

*** TODO Ponderables [0/2]:

+ [ ] implement a multibyte input with an array of chars.
*ANSWER*: remember that =read= (helpfully) returns the number of characters read, so that you can tell if you've read a 3-byte keypress or a 4-byte one.

I probably won't implement this, given that the course itself intends on handling such keypresses in the next section.

+ [ ] (source spelunking) find out how iscntrl() is implemented -- and why it throws up a /segmentation fault,/ of all things.

** Commit 14

+ we move to the next page of the tutorial, which is titled *Raw Input and Output*
+ the first part involves setting =C-q= to quit the program (understandable, since we want to be able to input 'q' to our texteditor)
+ my first approach would have been to change the conditional for quitting from =c == 'q'= to =c == 17= (well, I ran the program to see what the value of =C-q= was when read)
+ the tutorial follows a more curious approach:
  + we first use a #define to define a macro; for now my undestanding of preprocessor macros is that they will be dropped in place by the preprocessor, wherever they are found
  + this particular macro is defined as: =#define CTRL_KEY(k) ((k)& 0x1F)=
  + ie, we appear to be applying bitwise AND of our key with this value 0x1F, which is 0b00011111 in binary.
  + this implies nuking the top 3 bits in the character that is input
  + for 'q', which is 113 (0b01110001), bitwise AND with 0b00011111 will yield 0b00010001, which is 17, which is indeed the value of =C-q=
  + what sorcery is this
+ I shall follow the tutorial's method, since it does away with having to find the respective control key codes for future keymaps +and because it feels like magic+.


*** Ponderables [1/2]:

+ [X] I wanted to test if this technique worked with control + capital letters too, but to my surprise I found that =C-S q= is registered as =C-q=. Explain.
*ANSWER*: this probably has something to do with how capital alphabets are actually positioned in ASCII -- 'a' is 97, 'A' is 65. 

| key | integer | binary     | after nuking | integer |
|-----+---------+------------+--------------+---------|
| 'a' |      97 | 0b01100001 | 0b00000001   |       1 |
| 'A' |      65 | 0b01000001 | 0b00000001   |       1 |
| 'z' |     122 | 0b01111010 | 0b00011010   |      26 |
| 'Z' |      90 | 0b01011010 | 0b00011010   |      26 |
|-----+---------+------------+--------------+---------|

can transition from small letters to capital letters by flipping the 5th bit -- which adds/subtracts 32 (bits are counted from 0, TIL).

so if I needed to distinguish between =C-S-q= and =C-q=, like emacs does, this way would not work.

+ [ ] I reverted the code to just quitting with 'q', and tried to see if the =C-S-q= type keys were registered differently -- they weren't! how does emacs do it then?

** Commit 15

+ this commit involves cleaning up code
+ the keypress reading mechanism in =main= will be moved to two functions, =editorProcessKeypress= and =editorReadKey=.

+ =editorReadKey()= is a low level function (ie not very semantic) that deals with receiving keypresses.
+ =c= stores the value read, =nread= is an integer to keep track of the status of the read operation
+ the conditional of the while loop reads a single character into =c=, and if this was successful, it breaks out of the loop.
  + the return value of the =read= operation is stored in =nread= in the conditional itself (HINT: the return value of the assignment operator is the rvalue, or the value being assigned)
  + if =nread= is -1 (ie, an unsuccessful read, as mentioned in =man 2 read=; =errno= is also set), we enter the body of the loop, where we further check if =nread= is -1, and if =errno= is /not/ EAGAIN
  + if this conditional is satisfied, we call =die()=, since it appears to be a fatal error; else we loop again.
  + (see ponderables on why we check for =nread= being -1)
+ if the read was successful, we return =c=

+ =editorProcessKeypress()= processes the keys received by =editorReadKey()= and acts on it -- it's a higher level, semantic function.
  + the function calls =editorReadKey()= and stores it in a char =c=
  + a =switch= statement for =c= is run, where, for now, we test if =c == CTRL_KEY(q)=, in which case we call =exit(0)= -- a clean exit
  + I also modified the code to exit raw mode if the exit is due to =C-q=; which restores the terminal properties to sane values. I checked that they were indeed reset by using =diff= and a pair of =stty -a='s.


*** Ponderables [3/3]:

+ [X] why do we test if =nread == -1= inside the =if= inside the loop in =editorReadKey()=?
*ANSWER*: when reading, we are requisitioning 1 byte from STDIN; =read= returns the number of bytes read successfully. however, =read()= /can/ return 0, in the case that it has encountered EOF -- i.e. the read has been successful, but has encountered the end of input.

although we have disabled EOF when we set raw mode, (for instance, =C-d= will send a 4, and not EOF), and I can't think of any way right now to send an EOF to the program (future: maybe when reading from a physical file and encountering EOF?), it seems like good practice to call for =die()= only when it is actually an error.

+ [X] what happens when you call =perror= when there has been no error?
*ANSWER*: googling tells me that it displays "No error". I would like to see this for myself, but I don't want to reenable canonical mode for this (to send =C-d=)

+ [X] in case of =C-q=, =exit(0)= is called immediately; why is =disableRawMode()= not called? test! and modify if appropriate
*ANSWER*: indeed, raw mode is not disabled by exiting immediately. I shall fix this -- (can switch cases hold code blocks -- yes).

** Commit 16

+ this commit involves setting up a screen refresh.
+ we create a function =editorScreenRefresh()=, which writes the value =0x1B[2J= (also stylized as =\01B[J=
+ =0x1B= is 27 in decimal, which is the code for ESC, as we may recall.
+ this /string literal/ is an /escape sequence/ for the *VT100* terminal; all the escape sequences are documented here: [[https://vt100.net/docs/vt100-ug/chapter3.html][Digital VT100 User Guide]].
  + note that since it's a string, it is null-terminated ... hmmm
+ the escape sequence in question is /Erase in Display/. the general code for this is =ESC [ * J=, and it takes three possible parameters (*), which work as follows:

| parameter | effect                                                        |
|-----------+---------------------------------------------------------------|
|         0 | erase from active position to end of screen (default)         |
|         1 | erase from start of screen to active position                 |
|         2 | erase all of display, set to single width, position preserved |
|-----------+---------------------------------------------------------------|

+ so, our program uses the third parameter to clear the entire screen.
+ the tutorial calls this function inside the loop inside =main()=.
+ I wanted to study the clear screen in action, and this required printing the input characters to the screen, so, I modified the switch statement to the following:

#+BEGIN_SRC C
  switch(c) {
  case CTRL_KEY('q'):
    disableRawMode();
    exit(0);
    break;
  case CTRL_KEY('l'):
    editorRefreshScreen();
    break;
  default:
        printf("%c\r\n",c);
        break;
  }
#+END_SRC

(this tries to print control characters too, which will not be displayed. this is quite temporary)

holding =C-l= does clear the entire screen, but the cursor remains unmoved.

+ while I would like to see the effects of the other two parameters too, the setup is not yet ideal for it -- I would need to be able to move the cursor back to delete the screen from the point to the end of the screen; so I shall defer this exercise
+ since my implementation with =C-l= seems more sensible, I shall deviate from the tutorial in this regard, for now.


*** Ponderables [2/2]:

+ [X] what is the difference between '\x1B2J' and "\x1B2J"?
*ANSWER*: (the rough answer, because lazy): values encoded in single quotes are meant to be only for single characters, and in cases like this, they are called /multicharacter literals/ and are of type int; the exact value of which varies with the implementation (avoid them!)

the other is a good old, NULL terminated string literal ... which brings us to the next question:

+ [X] we appear to be writing 4 characters from the string "\x1B[2J", which has 5 characters if we include the terminating NULL. explain this disparity.
*ANSWER*: recall that =write= tries to write as many bytes as specified in the third parameter, from the buffer; it is completely fine if the nunmber of bytes to be written is smaller than the size of the buffer, which is what is happening in this case.

** Commit 17

+ (meta) I want to have function prototypes, instead of cluttering up the section before =main()= with function definitions. also fixes the problem of functions being detected to be /implicit/ by the compiler, which I had last time.
  + time I internalized emacs' cut-copy-paste terminology and keybindings. (a silent RIP to my /Mastering Emacs/ endeavour, although it did lead me this far)

| action | emacsila | keybinding |
|--------+----------+------------|
| cut    | kill     | =C-w=      |
| copy   | kill (?) | =M-w=      |
| paste  | yank     | =C-y=      |
|--------+----------+------------|

+ in the last commit, we managed to clear the screen by writing a VT100 escape sequence to the terminal; this did clear the entire screen, however, the cursor was still back to where it was.
+ the escape sequence /Cursor Position/ sets the cursor at the position where we direct it to: =Esc [ * ; * H=, where the two parameters are for the position of the cursor.
  + values of 0 or 1 for the parameters move the cursor to the first line or column,respectively
    + the tutorial mentions that line and column numbers are numbered from 1, btw.
  + /note/: the parameters are =line; column=, not the usual =(x,y)= coordinates. this is also okay, since semantically it is easier to invoke the notion of a line before that of the column
  + not specifying any particular values defaults to a home action

+ time to implement this!
+ I have decided to make the escape sequence explicit, instead of resorting to the defaults.
+ clear the screen while exiting -- both for clean exits and exit in case of a failure; be sure to clear screen before calling =perror=, or the error message will be lost.

*** Ponderables [3/3]:

+ [X] can I change cursor position by skipping one of the parameters?
*ANSWER*: indeed, I can. although I think there might be more fine tuned escape sequences for moving the cursor up and down.

+ [X] what happens if I use an index larger than the dimensions afforded by my window? will there be a wrap-around?
*answer*: no, it maxes out at the very end of the available frame. 

in trying this out, I learned that I need to increase the number of bytes being written to STDOUT if one of my parameters is in 2 or more digits, say, ie =write(STDOUT_FILENO, "\x1b[3;3H",6);= will have to be modified to =write(STDOUT_FILENO, "\x1b[30;30H",8);=. makes sense. if I had a more complex use case, I would use write this escape sequence after constructing it with =strcat= and using =strlen= for the number of bytes.

+ [X] what happens when the dimensions of the window change? will previously over-the-top values become valid on-the-fly?
*ANSWER*: the cursor goes as far as it can go, depending on current window dimensions. when the window size is increased, the cursor does not change its position to the new possible value. applying =C-l= again will set it to the requested location/ maximum value, whichever is lower.

perhaps we will get to work with the SIGWINCH signal which is informs the process of a change in window size ...

** Commit 18

+ I don't quite understand the purpose of =editorRefreshScreen()= right now. Is it meant to clear the screen, or is it meant to build the general structure, with the extraneous elements such as the tildes to the left ... etc.
+ I shall not try to worry myself with aligning myself with how the tutorial implements some of these functions since this is bound to change significantly as we tack on better methods. I shall fix things later.
+ should I create a function to clear screen? yes I should.
  + I now use =clearScreen()= whenever I desire to clean it up.

+ the tutorial now attempts to print a column of tildes on the left. this is done in a function =editorDrawRows=, and this is embedded in =editorRefreshScreen=
  + this is done by printing tildes in a for loop (the tutorial does it 24 times, finding that this only fills up half the terminal in my usual setup, I doubled it to 48)

+ next, the tutorial creates an struct called =editorConfig= to save the state of the editor. for now, this struct just contains the previous global variable =orig_termios=, which has been used to store the original terminal settings. since =orig_termios= is now member of a struct, we need to modify its invocation throughout the program as =E.orig_termios= (=E= is the global variable of type =struct editorConfig=)

*** Ponderables [1/1]:

+ [X] is there any difference between defining a global variable right when the structure is defined and defining it later?
*ANSWER*: no. however, defining it separately seems to be much more clearer while reading code (although I really like this implicit declaration and find it very cool)

** Commit 19

*using ioctl() to obtain window size*

+ an easy way to obtain window size on linux is to use the =ioctl= function, which is not guaranteed to work on other unix-like systems. this method is later superceded by a more universal method.

+ =ioctl()= is a system call that manipulates the underlying device parameters of special files, such as terminals.
+ the second parameter to =ioctl()= is device-dependent request code
+ our usage of this function is as follows: =ioctl(STDOUT_FILENO, TIOCGWINSZ, &window_size)=.
  + here =TIOCGWINSZ= is an =ioctl= request code that asks for the terminal dimensions.
  + =window_size= is a struct defined as follows: (as found in =man 2 ioctl_tty=)

#+BEGIN_SRC C
struct winsize {
    unsigned short ws_row;
    unsigned short ws_col;
    unsigned short ws_xpixel; /* unused */
    unsigned short ws_ypixel; /* unused */
}
#+END_SRC
  + thus with the above =ioctl()= call, we can extract information about the current window to a local variable of type =struct winsize=, which, btw, happens to be defined in =/usr/include/bits/ioctl-types.h= (was redirected to this from =/usr/include/sys/ioctl.h=, which was the header file included in this program)

+ we construct a function =int getWindowSize(int*, int*)=, which obtains the window size and passes them on to the parameters by reference
+ the return value is 0 on success, or -1 in case the =ioctl()= call failed, or the window had only one column.

+ recall the struct =editorConfig= which so far contained only the original termios settings. well, we now modify it to hold two integers -- for the row and column dimensions of our terminal.
+ it is the pointers to these two elements of our modified  =editorConfig= that are inputs to =getWindowSize=.

+ we create a function =initEditor()= which calls =getWindowSize=, and if the call fails, dies with an appropriate message.
+ =initEditor()= is called at the start of the program in =main=, right after we enable raw mode.

+ using the obtained dimensions of our window, we can modify =editorDrawRows()= to use the proper dimensions of the terminal window.

*** Ponderables [1/1]:

+ [X] when asked to print the values of =E.screenrows=, the program prints 46 (in my usual i3 setup, with the terminal occupying half the screen). is this correct?

*ANSWER*: it does appear to be so. the i3header and i3bar below take up real estate, when I tried the same in fullscreen mode, I got a value of 49. when I tried this on the tty, it was 57! I guess font size does play a role. (this also might explain my love for the tty console ...)
(should try this program tmux, and see how that goes.)

however, there appears to be one line below which is not filled by a tilde; this may have to do something with the loop?

** Commit 20

+ I can see why =atexit()= is useful -- I would like to be able to disable raw mode in case of an error. right now, I have plugged in the =disableRawMode()= function into =die()=, but this feels flimsy. what if =die()= happens to be called on =tcsetattr()= failure? the program will recurse into oblivion.

+ in this commit, we devise a fallback method of determining window size, in case =ioctl()= fails.
+ let me try to outline the process, and I shall explain the code details (if required) later.

  1. try to get to the bottom right corner of the screen. this is done using the VT100 escape sequences /Cursor Forward/ (=ESC [ Pn C=) and /Cursor Down/ (=ESC [ Pn B=), which move the cursor right and down respectively, by =Pn= units. by using high values for =Pn=, we are guaranteed to hit the bottom right position. (this is preferred over /Cursor Position/ since the standard guarantees that /Cursor Forward/Down/ will not go beyond the limits of the frame, while behaviour of /Cursor Position/ upon overshooting bounds is not mentioned -- correct an earlier Ponderable!). We use values of 999 for this purpose.
  2. determine the current location of the cursor, using /Device Status Report/, the relevant code for which is: =ESC [ 6 n=: "Command from host, please report active position".
  3. the response to the /Device Status Report/ needs to be /read/ from the input buffer -- the output is of the form =ESC [row;colR=, where =row= and =col= are the coordinates of the cursor's position.
  4. we perform this read character by character into a string, until we hit the delimiting 'R', which is when the coordinates end
  5. this string is then parsed to yield the coordinates.

at this stage, we are not parsing the string, but instead printing it to the screen; where we can inspect it. parsing will be done in the next commit.

some code details:

+ we are modifying the functions created for the =ioctl()= way of inspecting to incorporate a fallback in case the =ioctl()= function fails.
+ =ioctl()= is unlikely to fail, since I am on linux, so to test this alternate pathway, the conditional is primed with a 1, ie we bypass what does work. this 1 will be removed later.
+ in this alternate pathway, we move the cursor to 999;999, exit with -1 if it fails, if successful, invoke the following function
+ a new function =getCursorPosition()= is written which takes pointers to row and columns integers and prints the /Device Status Report/ to the terminal
+ using a loop, we use =read()= on STDIN, character by character, and print it to the screen until the read fails (recall: =read()= fails on timeout according to our VTIME settings)
+ =editorReadKey()= is called to wait for a keypress; this is for persistence -- else the screen is cleared immediately and control passes on to =die()= and we exit
  + although this behaviour seems unnecessary. why does =getCursorPosition()= exit with a -1? *fixed*


*** Ponderables [2/3]:

+ [ ] implement =atexit()=. clean up =die()= if you do so.
+ [X] after using /Device Status Report/ to query for the current cursor position, we are reading the report from STDIN. does this make sense? why? what did you expect?
*ANSWER*: the terminal/terminal driver/ the I-don't-know-what receives the DSR, sends a response to the STDIN, where it is stored in the input buffer, waiting to be read. the following link is the closest I have found to explaining the situation: [[https://stackoverflow.com/a/38132923][Reading the Device Status Report ANSI Escape Sequence Reply]]. 

printing to the screen cannot be a solution -- it's not possible to seek a particular location and query the terminal as to what is written there (at this stage, at least). this is most probably a primitive behaviour with ancient terminals that is being kept alive for backward compatibility.

+ [X] how can I replicate this "writing to STDIN buffer" behaviour ... for science, you know?
*ANSWER*: this one seems hard. @A suggested an approach involving pipes, and another involving writing to the FD of the underlying terminal (this required higher permissions); but I wanted to know if there was a simpler way involving just C ... there probably isn't.

** Commit 21

+ in this commit we parse the output in =getCursorPosition()= and send the dimensions back to =getWindowSize()=

+ the first step is to copy the string in the input buffer and store it in a string, which we call =buf[32]= (of length 32 ... reasonably large)
  + reading into this string is done using =read()= in a loop, reading one character in each iteration.
  + the loop is built to end when the length of the buffer is exhausted
  + the delimiting character is 'R', so we break from the loop when this is read.
  + we also =break= if there is nothing more to be read from STDIN, ie =read()= does not return a 1 (recall that =read()= returns the number of bytes successfully read, and that we are reading one byte at a time)
  + once out of the loop, =buf[i]= is set to '\0', ie padded with a NULL (=printf/sscanf= require NULL terminated strings)
+ since the above loop breaks both in the case of a legitimate response, and in case =read()= fails for some other reason, we check if the first two characters in =buf= are '\x1b' and '['; else we return -1
+ next we use the function =sscanf()=
  + =sscanf()= is like =scanf()=, except that it takes its input from a string instead of STDIN
  + =sscanf()= can also take a format string, and read values from it by parsing it according to this format string. for instance, our format string is: ="%d;%d=, starting from =buf[2]=, and read into the pointers =rows= and =cols= respectively. what this means is that =sscanf()= is being told the string looks like two ints separated by a semicolon, and to parse and read these ints into the variables provided.
  + if this process fails, ie =sscanf()= fails to return 2, corresponding to 2 successful int reads, we return with a -1
+ if the program has come this far, we have successfully extracted the cursor's location, and we can =return 0;=

now that this fallback method has been tested, we can remove the =1 ||= in the =getWindowSize()= conditional.

+ a final, minor, fix. the last line does not display a '~' due to '\r\n' being printed when on the last line, causing the terminal to scroll down onto a new line. this can be fixed now that we know the dimensions of the terminal: print newlines only if the index is less than =E.screenrows-1=. (this -1 does bother me, but I am too tired for such pedantry.)

*** Ponderables [/]:

+ regarding =sscanf()= format strings: how about using ="'\x1b[%d;%dR"= (parsing/testing the entire string) and ="%d;%dR"= (from =buf[2]=)?
*ANSWER*: ah. when we breaking from the loop upon reading 'R', we do not increment the index; hence =buf[i]='\0'= replaces 'R' with '\0', so there is no 'R' to match (does =sscanf()= fail if the format string contains an 'R' but the input string doesn't? -- no, it still succeeds, because two ints have been read successfully, remember: we are testing for the success of two reads, which have already happened when the pattern matching for 'R' fails)
